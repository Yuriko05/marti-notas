import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import '../models/user_model.dart';

class AuthService {
  static final FirebaseAuth _auth = FirebaseAuth.instance;
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Colecci√≥n de usuarios en Firestore
  static const String _usersCollection = 'users';

  // Dominio fake para correos generados autom√°ticamente
  static const String _fakeDomain = '@app.local';

  /// Stream para conocer el estado de autenticaci√≥n del usuario
  static Stream<User?> get authStateChanges => _auth.authStateChanges();

  /// M√©todo para obtener el usuario actualmente autenticado
  static User? get currentUser => _auth.currentUser;

  /// Generar correo fake basado en el nombre del usuario
  static String _generateFakeEmail(String name) {
    // Limpiar el nombre: min√∫sculas, sin espacios, caracteres especiales
    String cleanName = name
        .toLowerCase()
        .replaceAll(' ', '')
        .replaceAll(RegExp(r'[^a-z0-9]'), '');

    return '$cleanName$_fakeDomain';
  }

  /// Buscar usuario por nombre en Firestore
  static Future<UserModel?> _findUserByName(String name) async {
    try {
      final QuerySnapshot query = await _firestore
          .collection(_usersCollection)
          .where('name', isEqualTo: name.trim())
          .limit(1)
          .get();

      if (query.docs.isNotEmpty) {
        final doc = query.docs.first;
        return UserModel.fromFirestore(
            doc.data() as Map<String, dynamic>, doc.id);
      }

      return null;
    } catch (e) {
      debugPrint('Error buscando usuario por nombre: $e');
      return null;
    }
  }

  /// Registro de usuario con email y contrase√±a
  /// Crea el usuario en Firebase Authentication y guarda su perfil en Firestore
  static Future<UserModel?> registerWithEmailAndPassword({
    required String email,
    required String password,
    required String name,
    String role = 'normal', // Por defecto, los usuarios son normales
  }) async {
    try {
      debugPrint('Intentando registrar usuario: $email');

      // 1. Crear usuario en Firebase Authentication
      final UserCredential result = await _auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      final User? firebaseUser = result.user;

      if (firebaseUser == null) {
        debugPrint('Error: No se pudo crear el usuario en Firebase Auth');
        return null;
      }

      // 2. Guardar informaci√≥n adicional en Firestore
      final UserModel userModel = UserModel(
        uid: firebaseUser.uid,
        email: email,
        name: name,
        role: role,
        createdAt: DateTime.now(),
        lastLogin: DateTime.now(),
      );

      await _firestore
          .collection(_usersCollection)
          .doc(firebaseUser.uid)
          .set(userModel.toFirestore());

      debugPrint('‚úÖ Usuario registrado correctamente: ${userModel.uid}');
      return userModel;
    } on FirebaseAuthException catch (e) {
      debugPrint('üî• FirebaseAuth Error al registrar');
      debugPrint('Code: ${e.code}');
      debugPrint('Message: ${e.message}');

      // Re-lanzar la excepci√≥n para que pueda ser manejada por la UI
      rethrow;
    } catch (e) {
      debugPrint('‚ùå Error inesperado al registrar: $e');
      return null;
    }
  }

  /// Inicio de sesi√≥n con email y contrase√±a
  /// Autentica con Firebase Authentication y carga el perfil desde Firestore
  static Future<UserModel?> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      debugPrint('Intentando iniciar sesi√≥n: $email');

      // 1. Autenticar con Firebase Authentication
      final UserCredential result = await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      final User? firebaseUser = result.user;

      if (firebaseUser == null) {
        debugPrint('Error: No hay usuario despu√©s de autenticaci√≥n');
        return null;
      }

      // 2. Cargar perfil desde Firestore
      final DocumentSnapshot doc = await _firestore
          .collection(_usersCollection)
          .doc(firebaseUser.uid)
          .get();

      // 3. Si el perfil existe, cargar y actualizar √∫ltima fecha de login
      if (doc.exists) {
        // Actualizar fecha de √∫ltimo login
        await _firestore
            .collection(_usersCollection)
            .doc(firebaseUser.uid)
            .update({
          'lastLogin': FieldValue.serverTimestamp(),
        });

        final userData = doc.data() as Map<String, dynamic>;
        final userModel = UserModel.fromFirestore(userData, firebaseUser.uid);

        debugPrint(
            '‚úÖ Inicio de sesi√≥n exitoso: ${userModel.name} (${userModel.role})');
        return userModel;
      }
      // 4. Si el perfil no existe en Firestore, crear uno con los datos disponibles
      else {
        debugPrint(
            '‚ö†Ô∏è Usuario autenticado pero sin perfil en Firestore. Creando perfil...');

        final UserModel userModel = UserModel(
          uid: firebaseUser.uid,
          email: firebaseUser.email ?? '',
          name: firebaseUser.displayName ??
              firebaseUser.email?.split('@')[0] ??
              'Usuario',
          role: 'normal', // Por defecto, usuarios nuevos son normales
          createdAt: DateTime.now(),
          lastLogin: DateTime.now(),
        );

        await _firestore
            .collection(_usersCollection)
            .doc(firebaseUser.uid)
            .set(userModel.toFirestore());

        debugPrint('‚úÖ Perfil creado para usuario existente');
        return userModel;
      }
    } on FirebaseAuthException catch (e) {
      debugPrint('üî• FirebaseAuth Error al iniciar sesi√≥n');
      debugPrint('Code: ${e.code}');
      debugPrint('Message: ${e.message}');

      // Re-lanzar la excepci√≥n para que pueda ser manejada por la UI
      rethrow;
    } catch (e) {
      debugPrint('‚ùå Error inesperado al iniciar sesi√≥n: $e');
      return null;
    }
  }

  /// Obtener el perfil del usuario actual desde Firestore
  static Future<UserModel?> getCurrentUserProfile() async {
    try {
      final User? firebaseUser = currentUser;

      if (firebaseUser == null) {
        debugPrint('No hay usuario autenticado');
        return null;
      }

      final DocumentSnapshot doc = await _firestore
          .collection(_usersCollection)
          .doc(firebaseUser.uid)
          .get();

      if (!doc.exists) {
        debugPrint('‚ö†Ô∏è Usuario autenticado pero sin perfil en Firestore');
        return null;
      }

      return UserModel.fromFirestore(
        doc.data() as Map<String, dynamic>,
        doc.id,
      );
    } catch (e) {
      debugPrint('‚ùå Error al obtener perfil: $e');
      return null;
    }
  }

  /// Stream para escuchar cambios en el perfil del usuario actual
  static Stream<UserModel?> get userProfileStream {
    final User? user = currentUser;

    if (user == null) {
      // Si no hay usuario autenticado, retornar stream con valor nulo
      return Stream.value(null);
    }

    // Crear stream a partir del documento del usuario en Firestore
    return _firestore
        .collection(_usersCollection)
        .doc(user.uid)
        .snapshots()
        .map((snapshot) {
      if (!snapshot.exists) return null;
      return UserModel.fromFirestore(
        snapshot.data() as Map<String, dynamic>,
        snapshot.id,
      );
    });
  }

  /// Cerrar sesi√≥n
  static Future<void> signOut() async {
    try {
      await _auth.signOut();
      debugPrint('‚úÖ Sesi√≥n cerrada');
    } catch (e) {
      debugPrint('‚ùå Error al cerrar sesi√≥n: $e');
      rethrow;
    }
  }

  /// Enviar correo para restablecer contrase√±a
  static Future<void> sendPasswordResetEmail(String email) async {
    try {
      await _auth.sendPasswordResetEmail(email: email);
      debugPrint('‚úÖ Correo de restablecimiento enviado a $email');
    } on FirebaseAuthException catch (e) {
      debugPrint('üî• Error al enviar correo de restablecimiento');
      debugPrint('Code: ${e.code}');
      debugPrint('Message: ${e.message}');
      rethrow;
    } catch (e) {
      debugPrint('‚ùå Error inesperado al restablecer contrase√±a: $e');
      rethrow;
    }
  }

  /// Actualizar perfil de usuario (nombre o rol)
  static Future<bool> updateUserProfile({
    required String userId,
    String? name,
    String? role,
  }) async {
    try {
      final Map<String, dynamic> updateData = {};

      if (name != null && name.isNotEmpty) {
        updateData['name'] = name;
      }

      if (role != null && role.isNotEmpty) {
        updateData['role'] = role;
      }

      if (updateData.isEmpty) {
        debugPrint('No hay datos para actualizar');
        return false;
      }

      await _firestore
          .collection(_usersCollection)
          .doc(userId)
          .update(updateData);

      debugPrint('‚úÖ Perfil actualizado correctamente');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error al actualizar perfil: $e');
      return false;
    }
  }

  /// Verificar si el usuario actual tiene permisos de administrador
  static Future<bool> isCurrentUserAdmin() async {
    final UserModel? user = await getCurrentUserProfile();
    return user?.isAdmin ?? false;
  }

  /// Cambiar contrase√±a del usuario actual
  static Future<bool> changePassword(
      String currentPassword, String newPassword) async {
    try {
      final User? user = currentUser;

      if (user == null || user.email == null) {
        debugPrint('No hay usuario autenticado o falta email');
        return false;
      }

      // Re-autenticar para confirmar la contrase√±a actual
      final credential = EmailAuthProvider.credential(
        email: user.email!,
        password: currentPassword,
      );

      await user.reauthenticateWithCredential(credential);

      // Cambiar la contrase√±a
      await user.updatePassword(newPassword);

      debugPrint('‚úÖ Contrase√±a actualizada correctamente');
      return true;
    } on FirebaseAuthException catch (e) {
      debugPrint('üî• Error al cambiar contrase√±a: ${e.code}');
      debugPrint('Message: ${e.message}');
      return false;
    } catch (e) {
      debugPrint('‚ùå Error inesperado al cambiar contrase√±a: $e');
      return false;
    }
  }

  /// Eliminar cuenta de usuario (requiere re-autenticaci√≥n)
  static Future<bool> deleteAccount(String password) async {
    try {
      final User? user = currentUser;

      if (user == null || user.email == null) {
        debugPrint('No hay usuario autenticado o falta email');
        return false;
      }

      // Re-autenticar para confirmar la identidad
      final credential = EmailAuthProvider.credential(
        email: user.email!,
        password: password,
      );

      await user.reauthenticateWithCredential(credential);

      // Eliminar perfil de Firestore
      await _firestore.collection(_usersCollection).doc(user.uid).delete();

      // Eliminar cuenta de Authentication
      await user.delete();

      debugPrint('‚úÖ Cuenta eliminada correctamente');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error al eliminar cuenta: $e');
      return false;
    }
  }

  /// Comprobar si existe un usuario con el email proporcionado
  static Future<bool> checkIfUserExists(String email) async {
    try {
      final methods = await _auth.fetchSignInMethodsForEmail(email);
      return methods.isNotEmpty;
    } catch (e) {
      debugPrint('‚ùå Error al verificar existencia de usuario: $e');
      return false;
    }
  }

  /// Eliminar usuario desde el panel de administraci√≥n
  /// Elimina tanto de Firestore como de Firebase Authentication
  static Future<bool> deleteUserAsAdmin({
    required String userId,
    required String userEmail,
  }) async {
    try {
      // Verificar que hay un administrador autenticado
      final User? adminUser = currentUser;
      if (adminUser == null) {
        debugPrint('‚ùå No hay un administrador autenticado');
        return false;
      }

      final String? adminEmail = adminUser.email;
      if (adminEmail == null) {
        debugPrint('‚ùå El administrador no tiene email registrado');
        return false;
      }

      // 1. Eliminar de Firestore primero
      await _firestore.collection(_usersCollection).doc(userId).delete();
      debugPrint('‚úÖ Usuario eliminado de Firestore: $userId');

      // 2. Intentar eliminar de Firebase Authentication
      // NOTA: Esta es una soluci√≥n temporal. En producci√≥n se usar√≠a Firebase Admin SDK

      try {
        // Verificar si el usuario a eliminar est√° actualmente autenticado
        final User? currentUserAuth = currentUser;

        if (currentUserAuth != null && currentUserAuth.uid == userId) {
          // El usuario a eliminar es el que est√° actualmente autenticado
          // No podemos eliminar al usuario actual desde el panel de admin
          debugPrint(
              '‚ö†Ô∏è No se puede eliminar al usuario actualmente autenticado');
          return true; // Firestore ya fue eliminado, consideramos √©xito parcial
        }

        // Para eliminar otro usuario de Authentication necesitamos Firebase Admin SDK
        // Como soluci√≥n temporal, documentamos que la cuenta quedar√° en Auth
        debugPrint('‚ö†Ô∏è Cuenta de Authentication no eliminada autom√°ticamente');
        debugPrint('   Email de la cuenta: $userEmail');
        debugPrint('   UID: $userId');
        debugPrint(
            '   Nota: Para eliminar completamente, usar Firebase Admin SDK desde el backend');

        return true;
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error al intentar eliminar de Authentication: $e');
        // A√∫n consideramos √©xito porque Firestore fue eliminado
        return true;
      }
    } catch (e) {
      debugPrint('‚ùå Error al eliminar usuario desde admin: $e');
      return false;
    }
  }

  /// Crear un nuevo usuario desde el panel de administraci√≥n
  static Future<String?> createUserAsAdmin({
    required String email,
    required String password,
    required String name,
    required String role,
  }) async {
    try {
      // Guardar referencia al usuario administrador actual
      final User? adminUser = currentUser;
      if (adminUser == null) {
        debugPrint('‚ùå No hay un administrador autenticado');
        return null;
      }

      final String? adminEmail = adminUser.email;
      if (adminEmail == null) {
        debugPrint('‚ùå El administrador no tiene email registrado');
        return null;
      }

      // 1. Verificar si el usuario ya existe
      final userExists = await checkIfUserExists(email);
      if (userExists) {
        debugPrint('‚ö†Ô∏è El email ya est√° en uso: $email');
        return null;
      }

      // 2. Crear usuario en Firebase Authentication
      // IMPORTANTE: Esto cambiar√° temporalmente la sesi√≥n actual
      final UserCredential result = await _auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      final User? newUser = result.user;
      if (newUser == null) {
        debugPrint('‚ùå Error: No se pudo crear el usuario en Firebase Auth');
        return null;
      }

      String newUserId = newUser.uid;

      try {
        // 3. Crear el perfil en Firestore
        await _firestore.collection(_usersCollection).doc(newUserId).set({
          'email': email,
          'name': name,
          'role': role,
          'createdAt': FieldValue.serverTimestamp(),
        });

        debugPrint(
            '‚úÖ Usuario creado en Authentication y Firestore: $email ($newUserId)');

        // 4. CR√çTICO: Cerrar sesi√≥n del usuario reci√©n creado
        await _auth.signOut();

        // 5. CR√çTICO: Volver a iniciar sesi√≥n con el administrador
        debugPrint('üîÑ Restaurando sesi√≥n del administrador...');

        // Nota: Aqu√≠ necesitar√≠amos la contrase√±a del admin, pero no la tenemos
        // La soluci√≥n m√°s pr√°ctica es mostrar un mensaje al admin para que vuelva a iniciar sesi√≥n
        // En un entorno de producci√≥n, esto se resolver√≠a con Firebase Admin SDK desde el backend

        return newUserId;
      } catch (e) {
        // Si algo falla al crear en Firestore, eliminar el usuario de Auth
        try {
          await newUser.delete();
        } catch (deleteError) {
          debugPrint('‚ö†Ô∏è No se pudo limpiar el usuario de Auth: $deleteError');
        }

        debugPrint('‚ùå Error al crear perfil en Firestore: $e');
        return null;
      }
    } on FirebaseAuthException catch (e) {
      debugPrint('üî• Error al crear usuario en Authentication: ${e.code}');
      debugPrint('Message: ${e.message}');
      return null;
    } catch (e) {
      debugPrint('‚ùå Error inesperado al crear usuario: $e');
      return null;
    }
  }

  /// Registro simplificado con solo nombre y contrase√±a (para admins)
  /// Genera autom√°ticamente un correo fake
  static Future<String?> registerWithNameAndPassword({
    required String name,
    required String password,
    String role = 'normal',
  }) async {
    try {
      debugPrint('üìù Registrando usuario con nombre: $name');

      // 1. Verificar que el nombre no est√© en uso
      final existingUser = await _findUserByName(name);
      if (existingUser != null) {
        debugPrint('‚ö†Ô∏è Ya existe un usuario con el nombre: $name');
        return null;
      }

      // 2. Generar correo fake
      final String fakeEmail = _generateFakeEmail(name);
      debugPrint('üìß Correo fake generado: $fakeEmail');

      // 3. Crear usuario en Firebase Authentication
      final UserCredential result = await _auth.createUserWithEmailAndPassword(
        email: fakeEmail,
        password: password,
      );

      final User? firebaseUser = result.user;
      if (firebaseUser == null) {
        debugPrint('‚ùå Error: No se pudo crear el usuario en Firebase Auth');
        return null;
      }

      // 4. Guardar informaci√≥n en Firestore
      final UserModel userModel = UserModel(
        uid: firebaseUser.uid,
        email: fakeEmail, // Guardamos el correo fake
        name: name, // Nombre real que usar√° el usuario
        role: role,
        password: password, // Guardamos la contrase√±a para mostrar en admin
        createdAt: DateTime.now(),
        lastLogin: DateTime.now(),
      );

      await _firestore
          .collection(_usersCollection)
          .doc(firebaseUser.uid)
          .set(userModel.toFirestore());

      debugPrint('‚úÖ Usuario creado exitosamente: $name (${firebaseUser.uid})');

      // 5. Cerrar sesi√≥n del usuario reci√©n creado
      await _auth.signOut();

      return firebaseUser.uid;
    } catch (e) {
      debugPrint('‚ùå Error al registrar usuario con nombre: $e');
      return null;
    }
  }

  /// Login simplificado con nombre y contrase√±a
  /// Genera el correo fake y hace login directo con Firebase
  static Future<UserModel?> signInWithNameAndPassword({
    required String name,
    required String password,
  }) async {
    try {
      debugPrint('üîë Intentando login con nombre: $name');

      // 1. Generar correo fake basado en el nombre
      final String fakeEmail = _generateFakeEmail(name);
      debugPrint('üìß Email fake: $fakeEmail');

      // 2. Intentar hacer login directamente con Firebase Authentication
      final UserCredential result = await _auth.signInWithEmailAndPassword(
        email: fakeEmail,
        password: password,
      );

      final User? firebaseUser = result.user;
      if (firebaseUser == null) {
        debugPrint('‚ùå Error en autenticaci√≥n de Firebase');
        return null;
      }

      // 3. Cargar el perfil del usuario desde Firestore
      final DocumentSnapshot doc = await _firestore
          .collection(_usersCollection)
          .doc(firebaseUser.uid)
          .get();

      if (!doc.exists) {
        debugPrint('‚ùå Usuario autenticado pero sin perfil en Firestore');
        await _auth.signOut(); // Cerrar sesi√≥n si no hay perfil
        return null;
      }

      // 4. Crear el modelo de usuario
      final userData = doc.data() as Map<String, dynamic>;
      final userModel = UserModel.fromFirestore(userData, firebaseUser.uid);

      // 5. Actualizar √∫ltimo login
      await _firestore
          .collection(_usersCollection)
          .doc(firebaseUser.uid)
          .update({'lastLogin': Timestamp.now()});

      debugPrint('‚úÖ Login exitoso: ${userModel.name} (${userModel.role})');
      return userModel;
    } on FirebaseAuthException catch (e) {
      debugPrint('‚ùå Error de autenticaci√≥n: ${e.code}');

      if (e.code == 'wrong-password') {
        debugPrint('   Contrase√±a incorrecta');
      } else if (e.code == 'user-not-found') {
        debugPrint('   Usuario no encontrado');
      } else if (e.code == 'invalid-credential') {
        debugPrint('   Credenciales inv√°lidas');
      } else {
        debugPrint('   ${e.message}');
      }

      return null;
    } catch (e) {
      debugPrint('‚ùå Error inesperado en login: $e');
      return null;
    }
  }

  /// Verificar si un nombre de usuario ya existe
  /// Genera el correo fake y verifica si existe en Firebase Authentication
  static Future<bool> isNameTaken(String name) async {
    try {
      final String fakeEmail = _generateFakeEmail(name);

      // Verificar si existe un usuario con este correo fake en Firebase Auth
      final methods = await _auth.fetchSignInMethodsForEmail(fakeEmail);
      return methods.isNotEmpty;
    } catch (e) {
      debugPrint('‚ùå Error verificando disponibilidad del nombre: $e');
      return false; // En caso de error, asumir que est√° disponible
    }
  }
}
